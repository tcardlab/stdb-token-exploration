"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSite = exports.contentProcessors = void 0;
exports.contentProcessors = {
    '.html': hoistHtml,
    '.json': JSON.stringify,
};
function hoistHtml(jsx) {
    const hoisted = new Set();
    return (jsx
        .replace(/<script .+?><\/script>|<link .+?>/g, (s, s2) => {
        hoisted.add(s);
        return '';
    })
        .replace(/<\/head>/, [...hoisted, '</head>'].join('')));
}
const isArrayFile = matcher(/\/.*(?<slug>\[.+\]).*(?<ext>\..+)\.js$/);
const isSingleFile = matcher(/(?<ext>\..+)\.js$/);
function processContent(content, ext) {
    const fn = exports.contentProcessors[ext];
    return fn ? fn(content) : content;
}
const processSite = (files) => {
    const outfiles = new Map();
    for (const file of files) {
        let match;
        if (match = isArrayFile(file.path)) {
            const exportedArray = file.module.require().default;
            for (const [name, content] of exportedArray) {
                const filepath = file.path.replace(match.slug, name);
                outfiles.set(filepath.slice(0, -3), processContent(content, match.ext));
            }
        }
        else if (match = isSingleFile(file.path)) {
            const exportedContent = file.module.require().default;
            outfiles.set(file.path.slice(0, -3), processContent(exportedContent, match.ext));
        }
        else {
            outfiles.set(file.path, file.content);
        }
    }
    return outfiles;
};
exports.processSite = processSite;
function matcher(regex) {
    return (str) => {
        return str.match(regex)?.groups;
    };
}
